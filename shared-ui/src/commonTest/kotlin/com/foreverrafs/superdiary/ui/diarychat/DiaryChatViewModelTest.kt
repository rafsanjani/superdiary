package com.foreverrafs.superdiary.ui.diarychat

import app.cash.turbine.test
import assertk.assertThat
import assertk.assertions.isEqualTo
import assertk.assertions.isFalse
import assertk.assertions.isNull
import assertk.assertions.isTrue
import com.foreverrafs.superdiary.ai.api.DiaryAI
import com.foreverrafs.superdiary.ai.domain.model.DiaryChatRole
import com.foreverrafs.superdiary.ai.domain.repository.DiaryAiRepository
import com.foreverrafs.superdiary.ai.domain.usecase.GetChatMessagesUseCase
import com.foreverrafs.superdiary.ai.domain.usecase.SaveChatMessageUseCase
import com.foreverrafs.superdiary.common.coroutines.TestAppDispatchers
import com.foreverrafs.superdiary.common.coroutines.awaitUntil
import com.foreverrafs.superdiary.core.logging.AggregateLogger
import com.foreverrafs.superdiary.domain.model.Diary
import com.foreverrafs.superdiary.domain.repository.DataSource
import com.foreverrafs.superdiary.domain.usecase.GetAllDiariesUseCase
import com.foreverrafs.superdiary.ui.feature.diarychat.DiaryChatViewModel
import dev.mokkery.answering.returns
import dev.mokkery.answering.throws
import dev.mokkery.every
import dev.mokkery.everySuspend
import dev.mokkery.matcher.any
import dev.mokkery.mock
import kotlin.test.AfterTest
import kotlin.test.BeforeTest
import kotlin.test.Ignore
import kotlin.test.Test
import kotlin.time.ExperimentalTime
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.ExperimentalCoroutinesApi
import kotlinx.coroutines.flow.flow
import kotlinx.coroutines.flow.flowOf
import kotlinx.coroutines.test.StandardTestDispatcher
import kotlinx.coroutines.test.advanceUntilIdle
import kotlinx.coroutines.test.resetMain
import kotlinx.coroutines.test.runTest
import kotlinx.coroutines.test.setMain

@OptIn(ExperimentalCoroutinesApi::class)
class DiaryChatViewModelTest {

    private val dataSource: DataSource = mock<DataSource>()
    private val diaryAiRepository: DiaryAiRepository = mock<DiaryAiRepository>()

    private val diaryAI: DiaryAI = mock<DiaryAI>()

    private lateinit var diaryChatViewModel: DiaryChatViewModel

    @OptIn(ExperimentalTime::class)
    @BeforeTest
    fun setup() {
        Dispatchers.setMain(StandardTestDispatcher())

        every { dataSource.fetchAll() }.returns(
            flowOf(
                listOf(
                    Diary(
                        id = 123L,
                        entry = "I am going horse riding today",
                    ),
                ),
            ),
        )
        every { diaryAiRepository.getChatMessages() }.returns(flowOf(emptyList()))
        everySuspend { diaryAiRepository.saveChatMessage(any()) }.returns(Unit)

        diaryChatViewModel = DiaryChatViewModel(
            diaryAI = diaryAI,
            getAllDiariesUseCase = GetAllDiariesUseCase(
                dataSource = dataSource,
                dispatchers = TestAppDispatchers,
            ),
            logger = AggregateLogger(emptyList()),
            saveChatMessageUseCase = SaveChatMessageUseCase(repository = diaryAiRepository),
            getChatMessagesUseCase = GetChatMessagesUseCase(repository = diaryAiRepository),
        )
    }

    @AfterTest
    fun teardown() {
        Dispatchers.resetMain()
    }

    @Test
    @Ignore
    fun `Should update responding to true when generating AI response`() = runTest {
        everySuspend { diaryAI.queryDiaries(any()) }.returns("hello boss")

        diaryChatViewModel.queryDiaries("hello World")

        diaryChatViewModel.viewState.test {
            val state = awaitUntil { it.isResponding }
            assertThat(state.isResponding).isTrue()
            cancelAndIgnoreRemainingEvents()
        }
    }

    @Test
    fun `Should update responding to false after generating AI response`() = runTest {
        everySuspend { diaryAI.queryDiaries(any()) }.returns("hello boss")

        diaryChatViewModel.viewState.test {
            diaryChatViewModel.queryDiaries("hello World")

            // Wait until there is a message generated by AI
            val state =
                awaitUntil { s -> s.messages.any { it.role == DiaryChatRole.DiaryAI } }

            cancelAndConsumeRemainingEvents()

            assertThat(state.isResponding).isFalse()
        }
    }


    @Test
    fun `Should include system and welcome messages right after initialization`() = runTest {
        // No history already configured in setup
        diaryChatViewModel.viewState.test {
            val state = awaitUntil { it.messages.any { m -> m.role == DiaryChatRole.System } }
            // System message should be first
            assertThat(state.messages.first().role).isEqualTo(DiaryChatRole.System)
            // Welcome message from AI should also be present somewhere after system
            assertThat(state.messages.any { it.role == DiaryChatRole.DiaryAI }).isTrue()

            cancelAndIgnoreRemainingEvents()
        }
    }

    @Test
    fun `Blank query is ignored without changing state`() = runTest {
        // Capture the current messages snapshot
        val initial = diaryChatViewModel.viewState.value
        diaryChatViewModel.queryDiaries("   ")
        advanceUntilIdle()
        val after = diaryChatViewModel.viewState.value

        assertThat(after.isResponding).isFalse()
        assertThat(after.messages.size).isEqualTo(initial.messages.size)
        assertThat(after.error).isNull()
    }

    @Test
    fun `AI returns null sets error and does not append AI message`() = runTest {
        everySuspend { diaryAI.queryDiaries(any()) }.returns(null)

        diaryChatViewModel.viewState.test {
            diaryChatViewModel.queryDiaries("tell me")

            val state = awaitUntil { it.error != null }

            assertThat(state.isResponding).isFalse()
            assertThat(state.error).isEqualTo("Failed to generate AI response")
            // The last message should be the user's query since AI failed
            assertThat(state.messages.last().role).isEqualTo(DiaryChatRole.User)
            cancelAndIgnoreRemainingEvents()
        }
    }

    @Test
    fun `AI throws exception sets generic error`() = runTest {
        everySuspend { diaryAI.queryDiaries(any()) } throws RuntimeException("boom")

        diaryChatViewModel.viewState.test {
            diaryChatViewModel.queryDiaries("hello")

            val state = awaitUntil { it.error != null }

            assertThat(state.isResponding).isFalse()
            assertThat(state.error).isEqualTo("An error occurred while processing your query")
            cancelAndIgnoreRemainingEvents()
        }
    }

    @Test
    fun `Diaries failure sets error during initialization`() = runTest {
        // Reconfigure data source to throw from its flow
        every { dataSource.fetchAll() }.returns(flow { throw IllegalStateException("fetch fail") })

        // Recreate VM to re-run init collection with the failing flow
        diaryChatViewModel = DiaryChatViewModel(
            diaryAI = diaryAI,
            getAllDiariesUseCase = GetAllDiariesUseCase(
                dataSource = dataSource,
                dispatchers = TestAppDispatchers,
            ),
            logger = AggregateLogger(emptyList()),
            saveChatMessageUseCase = SaveChatMessageUseCase(repository = diaryAiRepository),
            getChatMessagesUseCase = GetChatMessagesUseCase(repository = diaryAiRepository),
        )

        diaryChatViewModel.viewState.test {
            val state = awaitUntil { it.error != null }
            assertThat(state.error).isEqualTo("Failed to load diaries")
        }
    }

    @Test
    fun `On success user and AI messages are appended and saved`() = runTest {
        everySuspend { diaryAI.queryDiaries(any()) }.returns("answer")

        diaryChatViewModel.viewState.test {
            diaryChatViewModel.queryDiaries("question")

            val state = awaitUntil { current ->
                // Wait until an AI message appears after user's question
                current.messages.takeLast(2).let { tail ->
                    tail.size >= 2 &&
                        tail[0].role == DiaryChatRole.User &&
                        tail[1].role == DiaryChatRole.DiaryAI
                }
            }

            assertThat(state.isResponding).isFalse()
            cancelAndIgnoreRemainingEvents()
        }
    }
}
